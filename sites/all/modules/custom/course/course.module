<?php
/**
 * @file
 * Code for the Lacuna Stories Course feature.
 */

include_once 'course.features.inc';

define("COURSE_NODE_TYPE", 'course');
define("BIBLIO_NODE_TYPE", 'biblio');
define("DOCUMENT_NODE_TYPE", 'document');
define("COURSE_CURRENT_TABLE", 'course_current');
define("COURSE_CURRENT_CACHE_ID", 'course_current_cache');

/**
 * Implements hook_menu().
 */
function course_menu() {
  $items = array();
  $items['course-setup'] = array(
    'title' => 'Create a New Course',
    'description' => 'course creation.',
    'page callback' => 'course_create_authorize',
    'access callback' => 'course_setup_access',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'course.pages.inc',
  );
  $items['course-setup/add-course'] = array(
    'title' => 'Create Your New Course',
    'description' => 'course creation.',
    'page callback' => 'course_create',
    'access callback' => 'course_setup_access',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'course.pages.inc',
  );
  $items['course-setup/organize'] = array(
    'title' => 'Organize Materials',
    'description' => 'Organize course.',
    'page callback' => 'course_organize',
    'access callback' => 'course_setup_access',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'course.pages.inc',
  );
  $items['course-setup/add-materials'] = array(
    'title' => 'Add Material',
    'description' => 'Add course material.',
    'page callback' => 'course_add_material',
    'access callback' => 'course_setup_access',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'course.pages.inc',
  );
  $items['ajax/add-term/%'] = array(
    'page callback' => 'course_ajax_add_term',
    'page arguments' => array(2),
    'access callback' => 'course_setup_access',
    'type' => MENU_CALLBACK,
    'file' => 'course.pages.inc',
  );
  $items['ajax/delete-term/%/%'] = array(
    'page callback' => 'course_ajax_delete_term',
    'page arguments' => array(2,3),
    'access callback' => 'course_setup_access',
    'type' => MENU_CALLBACK,
    'file' => 'course.pages.inc',
  );
  $items['admin/config/content/lacuna-courses'] = array(
    'title' => 'Course Creation Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_admin_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
   );
  // Empty home (front) page, added onto via context
  $items['home'] = array(
    'page callback' => 'course_blank_page',
    'access callback' => TRUE,
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'course.pages.inc',
  );
  // "About This Course" callback. Link is defined separately in the feature.
  $items['about-course'] = array(
    'title' => 'About This Course',
    'page callback' => 'course_about_course',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'course.pages.inc',
  );
  $items['course-tags/autocomplete/%/%'] = array(
    'page callback' => 'course_tags_autocomplete',
    'page arguments' => array(2, 3),
    'type' => MENU_CALLBACK,
    'file' => 'course.pages.inc'
  );
  // Custom form to add terms to course-related tags for annotations
  // If they can create a course, they can add terms
  $items['annotation_tags/add'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_annotation_tags_add'),
    'access arguments' => array('create course content'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'course.pages.inc',
  );

  return $items;
}

/**
 * check permissions and token to create a course
 */
function course_setup_access() {
  global $user;
  $key = "Course_Auth_Code_User_" . $user->uid;
  $canCreate = user_access('create course content');

  // we only want to check access when we are actually on a protected page
  // not just when eg the link is displayed and the access functions are called.
  if (!course_is_protected_page()) {
    return TRUE;
  }

  // No auth code required plus, permissions to create a course
  if ($canCreate && !variable_get('course_require_auth')) {
    return TRUE;
  }

  // Allow instructors to add materials to an existing course w/o course auth code
  $allowed_paths = array('course-setup/organize', 'course-setup/add-materials');
  $gid = course_get_selected_course();
  if ($canCreate && !empty($gid) && in_array(current_path(), $allowed_paths)) {
    return TRUE;
  }

  // ANON
  if (user_is_anonymous()) {
    drupal_set_message("You must be logged in to create a Lacuna course.", 'status', FALSE);
    drupal_goto('user/login', array('query' => array('destination' => 'course-setup')));
  }
  // NO PERMS
  elseif (!$canCreate) {
    drupal_set_message("Please contact your institution's Lacuna administrator. Your account does not have access to create a course.", 'error', FALSE);
    return FALSE;
  }
  elseif (($cache = cache_get($key)) && $_COOKIE['Lacuna_Course_Setup' . $key] == $cache->data) {
    // VALID
    return TRUE;
  }
  // NO/MISMATCHED AUTHCODE
  else {
    drupal_set_message("Please type in the Authorization Code before creating a Lacuna course.", 'warning', FALSE);
    drupal_goto('course-setup');
  }
}

function course_is_protected_page() {
  $current_path = current_path();
  return (preg_match("/course-setup/", $current_path) && $current_path != 'course-setup');
}

function course_admin_form() {

  global $base_url;
  $form = array();

  $form['info'] = array(
    '#markup' => 'To set up a new course, visit <a href="/course-setup">' . $base_url . '/course-setup</a>'
  );
  $form['authorization'] = array(
    '#type' => 'fieldset',
    '#title' => t('Authorization'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  $form['authorization']['course_require_auth'] = array(
    '#type' => 'radios',
    '#title' => t('Require Code to Create Courses?'),
    '#description' => t('Select "Yes" to require instructors to have the authorization code before creating a course.'),
    '#default_value' => variable_get('course_require_auth', TRUE),
    '#options' => array(TRUE => 'Yes', FALSE => 'No'),
    '#required' => TRUE,
  );

  $form['authorization']['course_authcode'] = array(
    '#type' => 'textfield',
    '#title' => t('Authorization Code'),
    '#description' => t('Set the authorization code needed to create a Lacuna course.'),
    '#default_value' => variable_get('course_authcode', 'ChangeMe!'),
    '#required' => FALSE,
    '#states' => array(
      'visible' => array(
        ':input[name="course_require_auth"]' => array('value' => 1)
      )
    )
  );

  $form['taxonomies'] = array(
    '#type' => 'fieldset',
    '#title' => t('Default Taxonomies'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#description' => t('Set the default values that all new courses will receive. Separate each item by commas. Instructors will have a chance to change these when setting up their course.')
  );

  $form['taxonomies']['course_default_units'] = array(
    '#type' => 'textfield',
    '#title' => t('Units'),
    '#description' => t('Used to organize readings into units'),
    '#required' => TRUE,
    '#default_value' => variable_get('course_default_units', 'Week 1, Week 2'),
  );

  $form['taxonomies']['course_default_genre_doc'] = array(
    '#type' => 'textfield',
    '#title' => t('Genre - Materials'),
    '#description' => t('Used to classify materials by genre'),
    '#required' => TRUE,
    '#default_value' => variable_get('course_default_genre_doc', 'Fiction, Scholarship'),
  );

  $form['taxonomies']['course_default_genre_response'] = array(
    '#type' => 'textfield',
    '#title' => t('Genre - Responses'),
    '#description' => t('Used to classify student responses by genre'),
    '#required' => TRUE,
    '#default_value' => variable_get('course_default_genre_response', 'Essay, Fiction, Other, Reflection, Summary'),
  );

  return system_settings_form($form);
}

// Can user switch to given course?
function course_switch_access($gid) {
  // Note: og_is_member returns TRUE only for Active members, not pending or blocked
  return user_access('administer nodes') || og_is_member('node', $gid);
}

// Switch course context when a new course viewed, if allowed
// course_set_selected_course does our permissions check
function course_node_view($node, $view_mode, $langcode) {
  if ($view_mode == 'full' && $node->type == 'course') {
    course_set_selected_course($node->nid);
  }
}

/**
 * Implements hook_views_query_alter().
 * Updates existing views so that their results are limited to the current course
 */
function course_views_query_alter(&$view, &$query) {
  // List of the views to alter
  // Design note: the Course module here demonstrates knowledge about all the other Lacuna modules
  // Not an ideal situation. It would be better if the Course module had an API by which other modules
  // could register their views as needing course-level restrictions, then Course iterated through
  // that list to alter the queries in a more abstract way.
  $where_node_views = array('responses', 'documents', 'threads', 'all_content', 'my_content', 'responses_by_user', 'annotations_by_user', 'peer_groups');
  $where_user_views = array('people', 'all_emails');
	$gid = course_get_selected_course();

  if (empty($gid)) {
    $gid = -1;  // No active group, prevent access to all course content
  }

  // Filter node content by course
  if (in_array($view->name, $where_node_views)) {
    $query->add_where_expression(0, "node.nid IN (SELECT etid FROM og_membership WHERE gid = " . $gid . " AND og_membership.entity_type = 'node')");
  }

  if ($view->name == 'comments_by_user') {
    // This view uses 'node_comment' not just 'node' as the table name
    $query->add_where_expression(0, "node_comment.nid IN (SELECT etid FROM og_membership WHERE gid = " . $gid . " AND og_membership.entity_type = 'node')");
  }

  // Filter users by course
  if (in_array($view->name, $where_user_views)) {
    $query->add_where_expression(2, "users.uid IN (SELECT etid FROM og_membership WHERE gid = " . $gid . " AND og_membership.entity_type = 'user')");
  }

  // Filter annotation tags by course
  if ($view->name == 'curate_tags') {
    $taxonomy = course_get_terms_for_current_course('annotation_tags');
    $query->add_where(0, 'tid', array_keys($taxonomy), 'IN');
  }

  // Autocomplete Bibliography field in Responses with only relevant bibliographic entries
  if ($view->name == 'bibliography_entity_reference_autocomplete') {
    $result = db_query('SELECT b.field_bibliographic_entry_target_id
      FROM field_data_field_bibliographic_entry b
      LEFT JOIN node n ON n.nid = b.entity_id
      LEFT JOIN og_membership ogm ON n.nid = ogm.etid
      WHERE ogm.entity_type = :entity_type
      AND ogm.gid = :gid', array(':entity_type' => 'node', ':gid' => $gid));
    $biblio_ids = array_keys($result->fetchAllKeyed());
    $query->add_where(2, 'node.nid', $biblio_ids, 'IN');
  }

	// Filter courses views for enrolled and not enrolled
	if ($view->name == 'courses') {
		switch ($view->current_display) {
			case 'not_enrolled':
				// This cannot be done in the view. It needs to be done in a query alter.
				// @see https://www.drupal.org/node/596860#comment-10030507
				$query->add_where_expression(2, "node.nid NOT IN (SELECT gid FROM og_membership WHERE entity_type = 'user' AND etid = ***CURRENT_USER***)");
				break;
			case 'enrolled':
				// This could be done in the view. Doing here for simplicity and organization.
				$query->add_where_expression(2, "node.nid IN (SELECT gid FROM og_membership WHERE entity_type = 'user' AND etid = ***CURRENT_USER***)");
				break;
		}
	}
}

/**
 * Implements hook_views_pre_render().
 */
function course_views_pre_render(&$view) {

  // User-contributed JS that prevents autosubmit on text views exposed text field filters for (while typing, still autosubmits on tab or enter). See https://www.drupal.org/node/1217948#comment-9233357
  // TODO: For now I have this loading on all views, but we may wish to only load for the specific views where this is needed
  // TODO: This is not not specific to courses. Once we have a general core feature, move this there
  drupal_add_js(drupal_get_path('module', 'course') . '/js/prevent-auto-submit.js', array('weight' => 10));
  switch ($view->name) {
    case 'courses':
      // "Not Enrolled" title is redundant when anon is viewing (front page), so hide the title
      if (user_is_anonymous()) {
        $view->set_title(' '); // space required
      }
      break;
    case 'archived_materials':
      drupal_add_css(drupal_get_path('module', 'course') . '/course.css');
      break;
  }
}

// Filter taxonomy terms to return only those relevant for current course
function course_get_terms_for_current_course($taxonomy_name, $gid = NULL) {
  if (empty($gid)) {
    $gid = course_get_selected_course();
  }
	$taxonomy = array();
	if ($gid) {
		$query = new EntityFieldQuery();
		$result = $query->entityCondition('entity_type', 'taxonomy_term')
			->entityCondition('bundle', $taxonomy_name)
			->fieldCondition('field_term_course', 'target_id', $gid, '=')
			->propertyOrderBy('weight')
			->execute();
		if (isset($result['taxonomy_term'])) {
			foreach(array_keys($result['taxonomy_term']) as $tid) {
				$wrapper = entity_metadata_wrapper('taxonomy_term', taxonomy_term_load($tid));
				$taxonomy[$tid] = $wrapper->name->value();
			}
		}
	}
	return $taxonomy;
}

// Returns list of documents in Ready to Annotate status for current course
function course_get_documents_for_current_course($gid = NULL) {
	if (empty($gid)) {
    $gid = course_get_selected_course();
  }
	$query = new EntityFieldQuery();
	$result = $query->entityCondition('entity_type', 'node')
		->entityCondition('bundle', 'document')
		->fieldCondition('og_group_ref', 'target_id', $gid)
		->fieldCondition('field_status', 'value', WORKFLOW_READY_STATE)
		->execute();
	if (isset($result['node'])) {
		return $result['node'];
	}
}

function course_get_responses_for_current_course($gid = NULL) {
  if (empty($gid)) {
    $gid = course_get_selected_course();
  }
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'response')
    ->fieldCondition('og_group_ref', 'target_id', $gid)
    ->propertyCondition('status', NODE_PUBLISHED)
    ->execute();
  if (isset($result['node'])) {
    return $result['node'];
  }
}

/*
 * Filter the bibliography nodes to those used in current course
 */
function course_get_bibliography_for_current_course($gid) {
	$documents = course_get_documents_for_current_course($gid);
	$biblios = array();
	if (!empty($documents)) {
		$docs = node_load_multiple(array_keys($documents));
		foreach ($docs as $doc) {
			$wrapper = entity_metadata_wrapper('node', $doc);
			array_push($biblios, $wrapper->field_bibliographic_entry->value());
		}
	}
	return $biblios;
}

/*
 * Get a list of relevant authors for exposed filter
 */
function course_get_authors_for_current_course($gid) {
	$authors = array();
	$biblios = course_get_bibliography_for_current_course($gid);
	foreach ($biblios as $biblio) {
		foreach ($biblio->biblio_contributors as $author) {
				$authors[$author['lastname']] = $author['name'];
		}
	}
	return $authors;
}

// Limit an exposed filter for taxonomy terms to those given
function course_limit_exposed_filter_tags(&$form, $field, $terms) {
  foreach ($form[$field]['#options'] as $tid => $term) {
    if (!isset($terms[$tid])) {
      unset($form[$field]['#options'][$tid]);
    }
  }
}

// Limit a list of users to only those in the current user's current course
function course_limit_user_list(&$form, $field_name, $gid) {
  $uids = array_keys($form[$field_name]['#options']);
  $form[$field_name]['#options'] = array();
  if ($cached = cache_get("course_users:$gid")) {
    $form[$field_name]['#options'] = $cached->data;
  };
  if (empty($form[$field_name]['#options']) and !empty($uids)) {
    // No cached data for this filter; let's calculate it, then store it
    $form[$field_name]['#options'] = array();	// wipe options
    foreach ($uids as $uid) {
      $account = user_load($uid);
      $groups = og_get_groups_by_user($account, 'node');  // very expensive call to make
      if (!empty($groups) && in_array($gid, $groups)) {
        $form[$field_name]['#options'][$uid] = format_username($account);
      }
    }
    cache_set("course_users:$gid", $form[$field_name]['#options'], 'cache', time() + 24 * 60 * 60);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function course_form_views_exposed_form_alter(&$form, &$form_state) {
  $gid = course_get_selected_course();

  if ('views-exposed-form-documents-materials' == $form['#id']) {
    // Set exposed filter 'Limit by Unit' for current course
		$form['field_unit_tid']['#options'] = course_get_terms_for_current_course('units', $gid);
		// Field name got reversed in Document field. Oops!
		// TODO: Fix the name
		$form['field_doc_genre_tid']['#options'] = course_get_terms_for_current_course('genre_doc', $gid);
		$form['lastname']['#options'] = course_get_authors_for_current_course($gid);
	}

  if ('views-exposed-form-responses-page' == $form['#id']) {
    // Limit response genre per course
    // TODO: Fix response_genre -> genre_response order swap
    $form['field_response_genre_tid']['#options'] = course_get_terms_for_current_course('genre_response', $gid);
  }

  // Use display name via Realname module, not user account name for author exposed form
	// Filter authors to only those in current course
	if (isset($form['author_select'])) {
    course_limit_user_list($form, 'author_select', $gid);
  }

  // For commenters on annotations
  if (isset($form['commenter_select'])) {
    course_limit_user_list($form, 'commenter_select', $gid);
  }

  // Filter Taxonomy terms
  if (isset($form['field_tags_tid'])) {
    course_limit_exposed_filter_tags($form, 'field_tags_tid', course_get_terms_for_current_course('annotation_tags', $gid));
  }

  if ($form['#id'] == 'views-exposed-form-sewing-kit-page') {
    // Restrict the tag filter options to tags on annotations on documents in courses in which the user is a member. Otherwise we will have inapplicable tags here even with no filters set. Plus tags may be considered private content.
    course_limit_exposed_filter_tags($form, 'field_annotation_tags_tid', course_get_terms_for_current_course('annotation_tags', $gid));

    // Restrict exposed filter list of annotated content to current course
    $documents = course_get_documents_for_current_course($gid);
    $doc_ids = array();
    if (isset($documents)) {
      $doc_ids = array_keys($documents);
    }
    $responses = course_get_responses_for_current_course($gid);
    $resp_ids = array();
    if (isset($responses)) {
      $resp_ids = array_keys($responses);
    }
    foreach ($form['document']['#options'] as $type => $options) {
      if (is_array($form['document']['#options'][$type])) {
        foreach ($form['document']['#options'][$type] as $nid => $title) {
          $nids = array();
          if (strtolower($type) == 'document') {
            $nids = $doc_ids;
          }
          if (strtolower($type) == 'response') {
            $nids = $resp_ids;
          }
          if (empty($nids) || !in_array($nid, $nids)) {
            unset($form['document']['#options'][$type][$nid]);
          }
        }
      }
    }
  }
}

// Shared With field in the Sewing Kit view, merges the Audience field and Peer Groups values (when applicable) into a single column to save space
function course_sewing_kit_shared_with($data) {
  $lines = array();
  foreach ($data->field_field_annotation_audience as $audience) {
    $audience_val = $audience['rendered']['#markup'];
    if ($audience['raw']['value'] == 'peer-groups') {
      $peer_groups = array();
      foreach ($data->field_og_group_ref as $group) {
        if ($group['raw']['entity']->type == 'peer_group') {
          $peer_groups[] = $group['rendered']['#markup'];
        }
      }
      $audience_val .= ' (' . implode (', ', $peer_groups) . ')';
    }
    $lines[] = $audience_val;
  }
  $output = implode (', ', $lines);
  if ($output) {
    return $output;
  }
}

// Get the currently selected course
// Used extensively, so be careful if you refactor
function course_get_selected_course() {
  global $user;

  $result = db_query('SELECT c.gid FROM {' . COURSE_CURRENT_TABLE . '} c WHERE c.uid = :uid', array(':uid' => (int) $user->uid));
	foreach ($result as $record) {
		return($record->gid);
	}

  // Note: this only happens the first time we check for a selected course
  // which affects only the call to this function in the main menu context
  $groups = og_get_groups_by_user($user, 'node');
  // Just set it to the first course node result
  if ($groups) {
    $gid = array_shift($groups);
    $group = node_load($gid);
    if ($group->type == 'course') {
      course_set_selected_course($gid);
      return $gid;
    }
  }
  return FALSE;
}

function course_set_selected_course($gid, $uid = NULL, $access_check = TRUE) {
  // Check for access to switch course
  // Behat tests need to be able to bypass this, though, hence $access_check
	if (empty($gid) || ($access_check && !course_switch_access($gid))) {
		return FALSE;
	}
	try {
    if (!isset($uid)) {
      global $user;
      $uid = $user->uid;
    }
		db_merge(COURSE_CURRENT_TABLE)
			->key(array('uid' => (int) $uid))
			->fields(array('gid' => $gid))
			->execute();
	}
	catch (Exception $e) {
		watchdog_exception('course_set_selected_course', $e, NULL, NULL, WATCHDOG_ERROR);
		drupal_set_message('Sorry, but an error occurred. Please notify a site administrator.', 'error');
		drupal_goto(drupal_get_destination());
	}
  return TRUE;
}

/*
 * Implements hook_node_validate
 */
function course_node_validate($node, $form, &$form_state) {
  if ($node->type == 'course') {
    // Ensure that multi-term courses are in consecutive terms
    $terms = $form_state['values']['field_course_term'][$node->language];
    if (count($terms) == 2) {
      $term1 = $terms[0]['value'];
      $term2 = $terms[1]['value'];
      if (($term1 == 'Fall' && $term2 == 'Spring') OR ($term1 = 'Winter' && $term2 == 'Summer')) {
        form_set_error('field_course_term', t('Multi-term courses must be in consecutive terms.'));
        // Todo: get this to highlight the term field in the failed form submission. Not sure what's up.
      }
    }
  }
}


/**
 * @param $form
 * @param $form_state
 * @param $form_id
 * Implements hook_form_FORM_ID_alter() for document nodes.
 */
function course_form_document_node_form_alter(&$form, &$form_state, $form_id) {
  $document = node_load($form['nid']['#value']);
	$unit_options = course_get_terms_for_current_course('units');
	$genre_options = course_get_terms_for_current_course('genre_doc');
  $units = array_keys($unit_options);
	$default_unit = array_shift($units);
  $genres = array_keys($genre_options);
	$default_genre = array_shift($genres);

	// Per-course units taxonomy
	if (isset($document->field_unit[LANGUAGE_NONE])) {
		$default_unit = $document->field_unit[LANGUAGE_NONE][0]['tid'];
	}
  $form['units'] = array(
    '#title' => 'Units',
    '#type' => 'select',
    '#size' => 60,
    '#default_value' => $default_unit,
    '#options' => $unit_options,
		'#required' => TRUE,
  );

	// Per-course Materials Genre taxonomy
	if (isset($document->field_doc_genre[LANGUAGE_NONE])) {
		$default_genre = $document->field_doc_genre[LANGUAGE_NONE][0]['tid'];
	}
	$form['genre_doc'] = array(
		'#title' => 'Genres',
		'#type' => 'select',
		'#size' => 60,
		'#default_value' => $default_genre,
		'#options' => $genre_options,
		'#required' => TRUE,
	);

	// Add our filtered fields to the correct groups
  $form['#group_children']['units'] = 'group_syllabus';
  $form['#group_children']['genre_doc'] = 'group_about';

	// Hide several default fields from user input - we're overriding them above
  $form['field_tags']['#access'] = FALSE;
  $form['field_unit']['#access'] = FALSE;
	$form['field_doc_genre']['#access'] = FALSE;
  $form['additional_settings']['#access'] = FALSE;
  $form['og_group_ref']['#access'] = FALSE;
  $form['field_bibliographic_entry']['#access'] = FALSE;
  // we always want the default settings here and don't want to confuse people
  $form['group_content_access']['#access'] = FALSE;

	// Finish up form
  $form['title']['#title'] = 'Title to Be Displayed to Students';
  $form['actions']['submit']['#value'] = 'Save (Finished Adding Material)';
  $form['actions']['submit']['#submit'] = array('course_add_document_form_submit');

  $form['actions']['submit2'] = array(
    '#type' => 'submit',
    '#submit' => array('course_add_document_form_submit'),
    '#value' => 'Save (Add More Material)',
  );

	$path = drupal_get_path('module', 'course');
  $form['#attached']['css'] = array("$path/course.css");
}

// Filter fields in Responses to current course context
function course_form_response_node_form_alter(&$form, &$form_state, $form_id) {
	$response = node_load($form['nid']['#value']);
	// Filter Response Genre to course
	$genre_options = course_get_terms_for_current_course('genre_response');
  $tids = array_keys($genre_options); // Avoid PHP warning about passing by reference :(
	$default_genre = array_shift($tids);
	if (isset($response->field_response_genre[LANGUAGE_NONE])) {
		$default_genre = $response->field_response_genre[LANGUAGE_NONE][0]['tid'];
	}
	$form['genre_response'] = array(
		'#title' => t('Genres'),
		'#type' => 'select',
		'#size' => 60,
		'#default_value' => $default_genre,
		'#options' => $genre_options,
		'#required' => TRUE,
    '#weight' => -10,
	);
	$form['#group_children']['genre_response'] = 'group_genre_about';
	$form['field_response_genre']['#access'] = FALSE;	// hide this field

  // Also filter the tags per course; we share the annotation tags
  $form['field_tags'][LANGUAGE_NONE]['#options'] = course_get_terms_for_current_course('annotation_tags');
  $form['field_tags']['#weight'] = -9;

  $form['og_group_ref']['#access'] = FALSE;	// We'll set the course automatically
  $form['group_content_access']['#access'] = FALSE; // hide confusing option; always private
  $form['actions']['submit']['#submit'] = array('course_add_response_form_submit');
	$form['actions']['submit']['#value'] = 'Save Response';
}

// Handle setting custom values
function course_add_response_form_submit($form, &$form_state) {
  $gid = course_get_selected_course();
  $node = node_form_submit_build_node($form, $form_state);
	$node->status = NODE_PUBLISHED;

	// Update node with our filtered values
  $wrapper = entity_metadata_wrapper('node', $node);
  // Genre can only have one option, so replace any existing values
  $wrapper->field_response_genre = array($form_state['values']['genre_response']);
  $wrapper->group_content_access->set(OG_CONTENT_ACCESS_PRIVATE);
  // og_group_ref must be set here so Responses show up for other users
  $wrapper->og_group_ref->set( array('target_id' => $gid ) );
  $wrapper->save();

  // Automatically assign to current course
  if ($gid && $node->nid) {
    og_group('node', $gid,
      array(
        'entity_type' => 'node',
        'entity' => $node,
        'field_name' => 'og_group_ref',
        'state' => OG_STATE_ACTIVE
      )
    );
    drupal_goto(drupal_get_path_alias('node/' . $node->nid));
  } else {
    drupal_set_message('There was a problem saving your response', 'warning');
  }
}

/**
 * @param $form
 * @param $form_state
 * @param $form_id
 *
 * Implements hook_form_FORM_ID_form_alter(). Modifies Peer Groups for course context.
 */
function course_form_peer_group_node_form_alter(&$form, &$form_state, $form_id) {
  $form['og_group_ref']['#access'] = FALSE;	// We'll set the course automatically
  $form['actions']['submit']['#submit'] = array('course_add_peer_group_form_submit');
}

/**
 * @param $form
 * @param $form_state
 *
 * Callback for peer-group node form submission.
 */
function course_add_peer_group_form_submit($form, &$form_state) {
  $node = node_form_submit_build_node($form, $form_state);
  $node->status = NODE_PUBLISHED;

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->save();

  // Automatically assign to current course
  $gid = course_get_selected_course();
  if ($gid && $node->nid) {
    og_group('node', $gid,
      array(
        'entity_type' => 'node',
        'entity' => $node,
        'field_name' => 'og_group_ref',
        'state' => OG_STATE_ACTIVE
      )
    );
    drupal_goto(drupal_get_path_alias('node/' . $node->nid));
  } else {
    drupal_set_message('There was a problem saving your Peer Group', 'warning');
  }
}

function course_form_biblio_node_form_alter(&$form, &$form_state, $form_id) {
  $form['copyright_status'] = array(
    '#type' => 'hidden',
    '#default_value' => -1,
  );
  $form['#submit'] = array('course_add_biblio_form_submit');
  $form['actions']['submit']['#submit'][] = 'course_add_biblio_form_submit';
  $form['actions']['submit']['#value'] = 'Save Bibliographic Information';
  $form['additional_settings']['#access'] = FALSE;

  unset($form['actions']['preview']);
  $path = drupal_get_path('module', 'course');
  $form['#attached']['css'] = array("$path/course.css");
  $form['#attached']['js'] = array("$path/course.js");
}

// NB: Needs to be in .module so it is always loaded or it can be excluded from module_implements() cache
function course_form_course_node_form_alter(&$form, &$form_state, $form_id) {
	// ensure AJAX media upload still has all the includes
	// @see https://www.drupal.org/node/1118114#comment-4575298
	$files = (isset($form_state['build_info']['files'])) ? $form_state['build_info']['files'] : array();
	$files[] = drupal_get_path('module', 'node') . '/node.pages.inc';
	$form_state['build_info']['files'] = $files;
  $form['#submit'] = array('course_create_form_submit');
  $form['actions']['submit']['#submit'][] = 'course_create_form_submit';
}

function course_create_form_submit($form, &$form_state) {
	global $user;
	// Only handle new courses, because we create these during the course setup process
	if (empty($form['nid']['#value'])) {
		$values = array(
			'type' => COURSE_NODE_TYPE,
			'uid' => $user->uid,
			'status' => NODE_PUBLISHED,
			'comment' => 0,
			'promote' => 0,
      'path' => array('pathauto' => TRUE),
		);
		$course = entity_create('node', array_merge($form_state['values'], $values));
		$course_wrapper = entity_metadata_wrapper('node', $course);
		try {
			$course_wrapper->save();
			$nid = $course_wrapper->nid->value();
			if (!empty($nid)) {
				course_set_selected_course($nid);
				drupal_goto("course-setup/organize");
			}
		}
		catch (Exception $e) {
			watchdog_exception('course_create_form_submit', $e, NULL, NULL, WATCHDOG_ERROR);
			drupal_set_message("There was an error creating your course.  Please try again and/or contact your institution's Lacuna administrator for assistance.", 'error');
			drupal_goto("course-setup/add-course");
		}
	}
}

// Create a new, blank document to associate with the new biblio node
// Pre-populated with bibliographic entity reference
function course_create_blank_document($biblio) {
  $gid = course_get_selected_course();

  // have to save in a cookie b/c biblio module form refreshes the page on type selection and borks with initial form render
  $copyright = '';
  if (isset($_COOKIE['course-material-type-' . $gid])) {
    $copyright = check_plain($_COOKIE['course-material-type-' . $gid]);
  }

  $document = new stdClass();
  $document->type = DOCUMENT_NODE_TYPE;
  $document->language = LANGUAGE_NONE;
  $document->title = $biblio->title;
  $document->field_doc_text[LANGUAGE_NONE][0]['value'] = $biblio->body[LANGUAGE_NONE][0]['value'];
  $document->field_doc_text[LANGUAGE_NONE][0]['format']  = filter_default_format();

  node_object_prepare($document);

  $document->field_bibliographic_entry[LANGUAGE_NONE][0]['target_id'] = $biblio->nid;
  $document->status = NODE_PUBLISHED; // make all documents published
  $copyright_terms = taxonomy_get_term_by_name($copyright);
  $taxo = array_pop($copyright_terms);
  if ($taxo) {
    $document->field_copyright[LANGUAGE_NONE][0]['tid'] = $taxo->tid;
  }
  node_save($document);

  // Add to course group
  og_group('node', $gid, array(
    'entity_type' => 'node',
    'entity' => $document,
    'field_name' => 'og_group_ref',
    'state' => OG_STATE_ACTIVE
  ));
  $form_state['rebuild'] = TRUE;

  if ($document->nid) {
    drupal_set_message("The document's bibliographic information has been saved. Now provide the document's text and course-specific information.");
    drupal_goto("node/" . $document->nid . "/edit");
  } else {
    drupal_set_message("There was an error adding your material. Please try again or contact your institution's Lacuna administrator.", 'error');
  }
}

/**
 * @param $vocab_name
 * @param $term
 * @return bool
 *
 * Returns results for query on course-based term in given vocabulary
 */
function course_get_taxonomy_term_in_current_course($vocab_name, $term) {
  if (empty($vocab_name)) {
    return FALSE;
  }
  $gid = course_get_selected_course();
  if ($gid) {
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'taxonomy_term')
      ->entityCondition('bundle', $vocab_name)
      ->fieldCondition('field_term_course', 'target_id', $gid, '=')
      ->propertyCondition('name', $term)
      ->execute();
    if (isset($result['taxonomy_term'])) {
      return $result['taxonomy_term'];
    }
  }
  return FALSE;
}

/**
 * @param $vocab
 * @param $tag
 * @param int $weight
 * Create new taxonomy terms that are linked to the current course
 */
function course_create_taxonomy_term($vocab, $tag, $weight = 0) {
  // first, check for existing term in per-course taxonomy
  $tag = trim($tag);
  $tags = explode(',', $tag);
  $gid = course_get_selected_course();
  $results = array();
  foreach ($tags as $tag) {
    if (course_get_taxonomy_term_in_current_course($vocab->machine_name, $tag) == FALSE) {
      // none found, create a new one
      $term = new stdClass();
      $term->name = $tag;
      $term->vid = $vocab->vid;
      $term->weight = $weight;
      $term->field_term_course[LANGUAGE_NONE][0]['target_id'] = $gid;
      taxonomy_term_save($term);
      $results[] = $term;
    }
  }
  return $results;
}

function course_add_biblio_form_submit($form, &$form_state) {
  $biblio = new stdClass();
  $biblio->type = BIBLIO_NODE_TYPE;
  foreach($form_state['values'] as $k => $v) {
    $biblio->$k = $v;
  }
  node_object_prepare($biblio);
  $biblio->status = NODE_PUBLISHED; // make all biblios published

  $isUpdate = isset($biblio->nid) || isset($biblio->is_new);
  node_save($biblio);
  // If this is an update to an existing biblio node,
  // Do not create a new blank document
  if (!$isUpdate) {
    course_create_blank_document($biblio);
  }
}

function course_add_document_form_submit($form, &$form_state) {
	global $base_url;

	$node = node_form_submit_build_node($form, $form_state);
  $node->status = NODE_PUBLISHED;

	// Update document node with our filtered values
  $node->field_unit[LANGUAGE_NONE][0]['tid'] = $form_state['values']['units'];
	// TODO: Rename field_doc_genre to field_genre_doc
	$node->field_doc_genre[LANGUAGE_NONE][0]['tid'] = $form_state['values']['genre_doc'];
  node_save($node);

	$message = "You have successfully added material to your course. To make the item available for annotation, remember to change the status to 'Ready for Annotation'. You can access all your course materials under <a href=\"" . $base_url . "/course-setup/add-materials\">Manage->Add Materials</a>";

  if ("Save (Finished Adding Material)" == $form_state['values']['op']) {
    drupal_set_message($message);
    unset($_GET['destination']);
    drupal_goto("/materials");
  }
  else if ("Save (Add More Material)" == $form_state['values']['op']) {
    drupal_set_message($message);
    unset($_GET['destination']);
    drupal_goto("course-setup/add-materials");
  }
}

/**
 * Implements hook_action_info().
 */
function course_action_info() {
  return array(
    'course_bulk_clone_material' => array(
      'type' => 'node',
      'label' => t('Add Material'),
      'configurable' => FALSE,
    ),
  );
}

function course_bulk_clone_material($biblios, $context = array()) {
  if (!is_array($biblios)) {
    $biblios = array($biblios);
  }
  $docs = array();
  foreach ($biblios as $biblio) {
    $doc = course_clone_material($biblio);
    if (!$doc) {
      drupal_set_message(t('Error adding material for @biblio', array('@biblio' => $biblio->title)), 'warning');
    }
  }

}

/**
 * NB: "material" is made up of a biblio entity (canonical info) and a doc entity (course-specific info)
 * Here, we are creating a new doc from an existing biblio, so it's cloning w/ air quotes people.
 */
function course_clone_material($biblio) {
  try {
    $course_nid = course_get_selected_course();
    if (!$course_nid) {
      return false;
    }

    $document = new stdClass();
    $document->type = DOCUMENT_NODE_TYPE;
    $document->language = LANGUAGE_NONE;
    $document->title = $biblio->title;
    $document->field_doc_text[LANGUAGE_NONE][0]['value'] = $biblio->body[LANGUAGE_NONE][0]['value'];
    $document->field_doc_text[LANGUAGE_NONE][0]['format']  = filter_default_format();

    node_object_prepare($document);
    $document->og_group_ref[LANGUAGE_NONE][0]['target_id'] = $course_nid;
    $document->field_bibliographic_entry[LANGUAGE_NONE][0]['target_id'] = $biblio->nid;
    $document->status = NODE_PUBLISHED; # make all documents published
    node_save($document);
    return $document;
  }
  catch (Exception $e) {
    watchdog('course_material_clone', $e, array(), WATCHDOG_ERROR);
    return false;
  }
}

function course_block_info() {
  $blocks = array();
  $blocks['course_finish_material_block'] = array(
    'info' => t('Finish Adding Material'),
    'cache' => DRUPAL_NO_CACHE,
    'status' => TRUE,
    'region' => 'help',
    'visibility' => BLOCK_VISIBILITY_NOTLISTED,
    'pages' => "node/*/edit\nadmin*",
    'theme' => 'lacuna_stories'
  );
  return $blocks;
}


function course_block_view($delta = '') {
  $block = array();
  switch($delta) {
    case 'course_finish_material_block':
      $block['subject'] = NULL;
      $block['content'] = array(
        '#markup' => course_finish_material_block_content()
      );
      break;
  }

  return $block;
}

function course_finish_material_block_content() {
  global $user;
  $key = "Lacuna_Course_Document_Creation_" . $user->uid;
  if (isset($_COOKIE['Lacuna_Course_Setup' . $key]) && $docs = $_COOKIE['Lacuna_Course_Setup' . $key]) {
    $docs = explode(',', $docs);
    foreach($docs as $doc) {
      $node = node_load($doc);
      drupal_set_message(t('You did not finish adding a document. The partially-completed information has been deleted.'), 'warning');
      ddl($node);
    }
  }
}

/**
 * Implements hook_node_access(). Prevent users from adding materials when they haven't selected a course context yet.
 */
function course_node_access($node, $op, $account) {
  if (user_access('administer nodes')) {
    // Avoid an infinite node access check!
    // Happens because course_get_selected_course() below may call
    // menu_get_object(), which called hook_node_access()
    return NODE_ACCESS_ALLOW;
  }

  if ($op == 'create' || $op == 'update' || $op == 'delete') {
    if (course_get_selected_course() == FALSE) {
      return NODE_ACCESS_DENY;
    }
  }
}

/**
 * Implements hook_node_delete(). Delete related taxonomy terms when course deleted.
 */
function course_node_delete($node) {
	if ($node->type == COURSE_NODE_TYPE) {
		$vocabularies = ['units', 'genre_doc', 'genre_response'];
		$query = new EntityFieldQuery();
		$result = $query->entityCondition('entity_type', 'taxonomy_term')
			->entityCondition('bundle', $vocabularies, 'IN')
			->fieldCondition('field_term_course', 'target_id', $node->nid, '=')
			->execute();
		if (isset($result['taxonomy_term'])) {
			foreach(array_keys($result['taxonomy_term']) as $tid) {
				taxonomy_term_delete($tid);
			}
		}
	}
}

/**
 * @param $account
 * Implements hook_user_delete(). Delete entries from course_current table.
 */
function course_user_delete($account) {
  db_delete(COURSE_CURRENT_TABLE)
    ->condition('uid', $account->uid)
    ->execute();
}

/**
 * Implements hook_og_membership_delete(). Remove user's access to a course entirely.
 */
function course_og_membership_delete(OgMembership $og_membership) {
  if ($og_membership->entity_type == 'user') {
    db_delete(COURSE_CURRENT_TABLE)
      ->condition('uid', $og_membership->etid)
      ->condition('gid', $og_membership->gid)
      ->execute();
  }
}